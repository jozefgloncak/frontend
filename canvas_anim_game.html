<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>

</head>
<body onload="startGame()"  style="margin:0">
    <canvas id="canv" height="500" width="400" ></canvas>

    <p>

    </p>
    <script>

        var myGame;

        function Game(ctx) {
            this.start = function() {
                console.log('start game');
                this.intervalHandler = setInterval(updateCanvas, 10);
            }

            this.stop = function() {
                clearInterval(this.intervalHandler);
            }

            this.intervalHandler;
            this.square;
            this.obstacles = [];
            this.ctx = ctx;
            this.gapMin = 100; //minimal size of gap
            this.gapMax = 150; //maximal size of gap

            this.isKeyUpPressed = false;
            this.isKeyDownPressed = false;
            this.isKeyLeftPressed = false;
            this.isKeyRightPressed = false;

            this.frameNum = 100;

            this.resetArrowKeyStatuses = function(keyCode, newState) {
                if (keyCode == 37) {
                    this.isKeyLeftPressed = newState;
                } else if (keyCode == 39) {
                    this.isKeyRightPressed = newState;
                } else if (keyCode == 38) {
                    this.isKeyUpPressed = newState;
                } else if (keyCode == 40) {
                    this.isKeyDownPressed = newState;
                }
            }

            this.generateObstacle = function() {
            //generate new obstacle every 150 frame. obstacle consists of vertical bar which has gap somewhere.
            //gap length is random from interval <minGap;maxGap>
                if (this.frameNum % 150 == 0) {
                    //genare gap length
                    let gap = this.gapMin + Math.random()*(this.gapMax - this.gapMin);

                    //generate upDown obstacle height. min remaining gap is > 3*square height
                    let upDownObstacleLength = Math.random() * (this.ctx.canvas.height - 3 * myGame.square.height);

                    this.obstacles.push(new Obstacle(this.ctx.canvas.width-1, 0, 10, upDownObstacleLength, "green", 1, this ));
                    if (upDownObstacleLength + gap < this.ctx.canvas.height) {
                        downUpObstacleLength = this.ctx.canvas.height - (upDownObstacleLength + gap);
                        this.obstacles.push(new Obstacle(this.ctx.canvas.width-1, upDownObstacleLength + gap, 10, downUpObstacleLength, "green", 1, this ));
                    }
                }                
            }

            this.updateCanvas = function() {
                //eveluate whether all obstacles are out of square
                this.obstacles.forEach(el => {
                    if (el.isCrashed(this.square)) {
                        this.stop(); 
                        return;                   
                    }
                });            

                //clear canvas
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

                //update square
                this.square.update();


                this.frameNum++;

                //remove obstacles which are out of cavnas
                this.obstacles = this.obstacles.filter(el => el.isInCanvas);

                //create new obstacles
                this.generateObstacle();

                //update position of obstacles
                this.obstacles.forEach(el => {
                    el.update();
                });

            }

        }

        function updateCanvas() {
            myGame.updateCanvas();
        }

        function startGame() {

            window.addEventListener("keydown", function(event) {
                console.log("keydown pressed ", event.keyCode);
                myGame.resetArrowKeyStatuses(event.keyCode, true);
                console.log(`right, left, down, up: ${myGame.isKeyRightPressed}, ${myGame.isKeyLeftPressed}, ${myGame.isKeyDownPressed}, ${myGame.isKeyUpPressed}`);
            });
        
            window.addEventListener("keyup", function(event) {
                console.log("keyup pressed ", event.keyCode);
                myGame.resetArrowKeyStatuses(event.keyCode, false);
            });

            //create instance of game class
            myGame = new Game(document.getElementById("canv").getContext("2d"));
            let sqr = new Square(10, myGame.ctx.canvas.height/2, 15, 15, "blue", 3, myGame);

            myGame.square = sqr;
            myGame.start();
        }
    
        class Component {
            constructor(x, y, width, height, color, delta, game) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.delta = delta;
                this.game = game;
            }
 
            updateInner(ctx) {
            }

            update() {
                let ctx = this.game.ctx;

                this.updateInner(ctx);

                ctx.fillStyle = this.color;
                ctx.strokeStyle = "black";
                ctx.fillRect(Math.floor(this.x) % ctx.canvas.width, this.y % ctx.canvas.height, this.width, this.height);
                ctx.stroke();
            }

            isCrashed(otherComponent) {
                let otherLeft = otherComponent.x;
                let otherRight = otherComponent.x + otherComponent.width;
                let otherTop = otherComponent.y;
                let otherBottom = otherComponent.y + otherComponent.height;
                let thisLeft = this.x;
                let thisRight = this.x + this.width;
                let thisTop = this.y;
                let thisBottom = this.y + this.height;

                if (thisLeft > otherRight || thisRight < otherLeft ||
                    thisBottom < otherTop || thisTop > otherBottom ) {
                        return false;
                }
                return true;
            }
        }

        class Square extends Component {
            constructor(x, y, width, height, color, delta, game) {
                super(x, y, width, height, color, delta, game);
            }

            updateInner(ctx) {
                if (this.game.isKeyDownPressed) {
                    this.y += this.delta
                }
                if (this.game.isKeyUpPressed) {
                    this.y -= this.delta
                }

                this.y = this.y < 0 ? 0 : this.y; //minimal height is zero
                this.y = this.y + this.height > ctx.canvas.height ? ctx.canvas.height - this.height: this.y; //maximal height is bottom of canvas
            }
        }

        class Obstacle extends Component {
            constructor(x, y, width, height, color, delta, game) {
                super(x, y, width, height, color, delta, game);
            }

            isInCanvas = true;

            updateInner(ctx) {
                if (this.x < 0 || this.x > ctx.canvas.width || this.y < 0 || this.y > ctx.canvas.height) {
                    this.isInCanvas = false;
                }
                this.x -= this.delta
            }
        }

    </script>
</body>
</html>

